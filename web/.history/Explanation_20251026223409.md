1️ State Management Strategy — Optimistic UI Update

Why it’s a good UX pattern:
Optimistic UI makes the application feel fast and responsive by immediately reflecting a change on the screen without waiting for the API response.
For example, when a user changes a campaign’s status, the update is shown instantly, creating the illusion of zero latency.
If the server later confirms success, the UI already matches the correct state; if it fails, the change is reverted.

Challenges:

1) Concurrency: If multiple updates happen quickly (e.g., two rapid status changes), the latest API response might arrive after a previous one, causing outdated data to overwrite fresh state.

2) Error Handling: Reverting to the previous state correctly after failure can be tricky — you need to store the old copy before updating.

3) Consistency with Server: If the server’s logic or data updates independently, optimistic UI might temporarily show an incorrect state until the next refresh.

How we handled it:
We saved the current campaign list before updating, performed an instant optimistic change in React state, and reverted it if the API call failed.

----------------------------------------------------------------------------------------------------------------------------------

2️ API Security — Simple API Key

Limitations of the API key approach:
1) Hardcoded & static: The key is visible in the client code or network requests, so anyone can reuse it.

2) No user context: It cannot differentiate users or roles.

3) No expiration or rotation: Once leaked, it remains valid indefinitely.

Real-world solution:
In a production system, we would replace this with JWT-based authentication (JSON Web Token) or OAuth 2.0.
These provide:

Token expiry and refresh mechanisms.

User-based identity and role-based access control.

Secure key exchange using HTTPS.
Alternatively, for internal service-to-service calls, API Gateway with HMAC or mTLS authentication would be appropriate.

--------------------------------------------------------------------------------------------------------------------------------

3️⃣ Performance — Handling Large Data Sets

If the campaign list grows to thousands of items, two main bottlenecks appear:

a) Rendering Bottleneck (React re-renders too much):
Each campaign row re-renders on every refresh or state change.
Solution:

Use React.memo or virtualized lists (e.g., react-window or react-virtualized) to render only visible rows.

Minimize re-renders by splitting large components into smaller memoized child components.

b) Network Bottleneck (Loading all data every few seconds):
Auto-refreshing thousands of campaigns every few seconds will strain both backend and frontend.
Solution:

Use incremental updates (e.g., fetch only changed records via WebSocket or polling diff).

Implement pagination or lazy loading so only a subset is fetched at a time.

Introduce debouncing or interval throttling to control refresh rate.